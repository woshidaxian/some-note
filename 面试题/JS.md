## BOM对象有哪些？
浏览器对象模型，提供了独立于内容与浏览器窗口进行交互的对象  
其作用就是跟浏览器做一些交互效果,比如如何进行页面的后退，前进，刷新，浏览器的窗口发生变化，滚动条的滚动，以及获取客户的一些信息如：浏览器品牌版本，屏幕分辨率  
Bom的核心对象是window，它表示浏览器的一个实例，在浏览器中，window对象有双重角色，即是浏览器窗口的一个接口，又是全局对象  
location、navigator（浏览器信息）、screen（显示器信息）、history

## 刷新页面的方式
 - location.reload(true?) 参数为true强制浏览器绕过缓存并重新加载页面
 - location.href window.location.href = window.location.href 对location.href赋值
 - location.replace() 用于在不添加历史记录的情况下刷新页面，将当前页面替换为新页面，从而实现刷新效果

## iframe的顶层对象
 - window.top 指向顶层窗口的全局JavaScript对象。通过window.top，您可以在iframe中执行顶层窗口中的JavaScript代码，或者与顶层窗口进行通信。
 - window.parent 是一个指向包含iframe的父窗口的全局JavaScript对象，访问父窗口的DOM、执行父窗口中的JavaScript代码，或者与父窗口进行通信

## base64算法原理？会什么会使数据量变大？变大了多少？
二进制到文本编码方案  
包括大写字母（A-Z）、小写字母（a-z）、数字（0-9）以及两个额外的字符（通常是"+"和"/"），共64字符  
  - 数据分组（3个字节/组【24位】，不足3字节则额外添加零字节）
  - 数据转化：原3个字节数据的二进制按位排列为一个长的二进制数字（24位整数）
  - 整数分割：将24位二进制整数按6位一组分割，2^6=64
  - 字符映射：每个6位的二进制数字转换为对应的Base64字符
  - 如果原始数据的长度不是3的倍数，将在末尾添加一些额外字符，通常是等号("=")，以确保输出是4的倍数
3个字节转换为4个base64字符，一个字符又对应了单个或多个字节，数据发生了膨胀，至少变大33%，以及位数不足时，“=”符号的补位

## 重排重绘？哪些api会引起？怎么优化？（重绘&回流）
  - 重排（回流）：布局引擎会根据各种样式计算每个盒子在页面上的大小与位置，当页面布局和几何信息发生变化的时候，例如添加删除元素、改变元素位置和大小，获取元素宽高位置信息也会触发（offsetTop、offsetLeft、 offsetWidth、offsetHeight、scrollTop、scrollLeft等，getComputedStyle方法也会触发）
  - 重绘：在回流之后，浏览器根据每个盒子特性进行绘制，触发回流一定会触发重绘，例如改变字体或背景颜色、文字排列对齐方式、阴影修改
  优化：1. 用修改元素的类名而不是直接修改样式属性  2.避免在 JavaScript 中查询元素的尺寸和位置信息，因为这可能会强制浏览器进行同步布局，导致重排。如果需要获取这些信息，可以使用 getBoundingClientRect() 等方法  3. CSS 动画和过渡通常比使用 JavaScript 进行动画更高效  4. 使用节流和防抖来限制事件处理的频率，以减少不必要的重排和重绘  5. 批量DOM操作，批量添加

## promise是什么？为什么产生回调地狱？
异步编程的一种解决方案，传统回掉会有多层嵌套，代码可读性差，promise链式操作减低了编码难度，代码可读性明显增强  
promise有三种状态：pending（进行中）、fulfilled（已成功）、rejected（已失败）
异步操作的嵌套，可读性差，错误处理困难，结构混乱

## 不用promise，怎么实现promise.all（实现第一个，第二个任务后，才执行第三个任务？用发布订阅实现，前两任务会同时派发吗，为什么？）
采用回调，对完成任务计数

## 怎么实现promise.race？


## 发布订阅模式和观察者模式的区别
观察者模式，观察者明确知道被观察对像，并订阅被观察者，当被观察者发生变化，会通知观察者，相互之间直接联系。通常一个被观察者对应多个观察者，每个观察者订阅同一被观察者事件    
发布-订阅模式，需要通过一个中间者，联系发布者和订阅者，它们之间互不感知，可以有多个发布者，订阅者只需要订阅感兴趣的内容

## 怎么处理长任务？
 1. 分割任务
 2. 使用异步编程
 3. 标识执行进度
 4. 优化算法，提高效率
 5. 定时器（确保任务不会无限期执行，及时通知用户）

## 如何按顺序发送多个请求（请求可能会失败）
 1. 回调
 2. promise异步编程
 3. async/await 异步编程

## 如何实现一个防止重复请求的方法？
记录请求地址，在拦截器中判断是否重复
取消请求 axios中的cancelToken或者使用promise当取消请求时直接reject返回

## 事件循环机制？宏任务？微任务？（js和node）js单线程，为什么会有异步任务
JavaScript是一门单线程的语言，意味着同一时间内只能做一件事，但是这并不意味着单线程就是阻塞，而实现单线程非阻塞的方法就是事件循环   
任务：
  - 同步任务：立即执行的任务，同步任务一般会直接进入到主线程中执行
  - 异步任务：异步执行的任务，比如ajax网络请求，setTimeout定时函数等
事件循环：同步任务进入主线程，即主执行栈，异步任务进入任务队列，主线程内的任务执行完毕为空，会去任务队列读取对应的任务，推入主线程执行。上述过程的不断重复就事件循环  
异步任务还可以细分为微任务与宏任务  
  - 微任务：一个需要异步执行的函数，执行时机是在主函数执行结束之后、当前宏任务结束之前。常见的微任务有：Promise.then、MutaionObserver（监视DOM变化）、Object.observe（已废弃；Proxy 对象替代）、process.nextTick（Node.js）
  - 宏任务：宏任务的时间粒度比较大，执行的时间间隔是不能精确控制的，对一些高实时性的需求就不太符合，script (可以理解为外层同步代码)、setTimeout/setInterval、UI rendering/UI事件、postMessage、MessageChannel、setImmediate、I/O（Node.js）
当前正执行一个宏任务，如果遇到微任务就将它放到微任务的事件队列中，当前宏任务执行完成后，会查看微任务的事件队列，然后将里面的所有微任务依次执行完

## js原型，原型链？
JS在创建对象的时候会关联另外一个对象，该对象即是当前所创建对象的原型，每个新创建的对象会从原型继承属性  
原型又会有自己关联的原型，一直关联至Object，这就形成了原型链

## 浅拷贝？深拷贝？
浅拷贝：如果属性是基本类型，拷贝的就是基本类型的值。如果属性是引用类型，拷贝的就是内存地址。Object.assign、slice、concat、拓展运算符实现的复制
深拷贝：复制后引用数据类型改动后互不影响。JSON.stringify()、手写递归复制

## JSON.stringfy方法有什么缺点？
对undefined、symbol、function会被忽略
不支持循环引用
不支持日期对象

## 作用域是什么？
作用域是变量和函数生效的区域合集，作用域决定了代码区块中变量和其他资源的可见性  
作用域包括全局作用域、函数作用域、块级作用域  
作用域链：代码执行时，变量首先会在当前作用域中寻找，没有找到就到上一层作用域查找，最后在全局作用域中寻找

## async/await和promise的区别？实现原理？
 - 编程风格：promise采用链式操作，async/await看起来像是同步代码
 - 错误处理：promise使用.catch方法，async/await需使用try...catch...捕获
 - 多个并发处理：promise支持promise.all、promise.race处理并发操作，async/await 通常更适用于按顺序处理异步操作

## 介绍一些new的过程中，有哪些步骤？
1. 创建一个新的对象obj
2. 将对象与构建函数通过原型链连接起来
3. 将构建函数中的this绑定到新建的对象obj上
4. 根据构建函数返回类型作判断，如果是原始值则被忽略，如果是返回对象，需要正常处理
```js
function mynew(Func, ...args) {
  // 1.创建一个新对象
  const obj = {}
  // 2.新对象原型指向构造函数原型对象
  obj.__proto__ = Func.prototype
  // 3.将构建函数的this指向新对象
  let result = Func.apply(obj, args)
  // 4.根据返回值判断
  return result instanceof Object ? result : obj
}
```

## 如何实现打印功能？
window.print()

## js基本数据类型和引用数据类型，如何判断类型？
typeof 可判断基本数据类型，typeof null 输出object（null被认为是对空对象的引用）
instanceof 可判断引用数据类型 检查对象的原型链以确定其是否是特定构造函数（或类）的实例
Object.prototype.toString.call() 可判断所有类型数据 输出格式为[object string/number/boolean/...]

## this指向问题？
- 全局上下文中，无论是否严格模式下，this都指向全局对象
- 在方法中，this 表示该方法所属的对象。
- 如果单独使用，this 表示全局对象。
- 在函数中，this 表示全局对象。
- 在函数中，在严格模式下，this 是未定义的(undefined)。
- 在事件中，this 表示接收事件的元素。
- 类似 call() 和 apply() 方法可以将 this 引用到任何对象。
- 同过new出来的，this指向新创建的实例对象

## 事件捕捉？事件冒泡？事件代理？事件流模型？
事件捕捉是事件传播的第一个阶段。事件从文档根节点（HTML元素）向目标元素的最外层元素传播，使用addEventListener() 方法，将事件监听器绑定到目标元素上  
事件冒泡是事件传播的第二个阶段，事件从目标元素冒泡到 document，依次检查经过的节点是否绑定了事件监听函数，如果有则执行，反之不执行。  
事件代理是一种优化技术，它允许你将事件监听器绑定到一个祖先元素，而不是在每个子元素上都绑定事件监听器。
当事件在子元素上触发时，事件会冒泡到祖先元素，然后在祖先元素上触发事件监听器。通过检查事件目标，你可以确定哪个子元素触发了事件。
事件代理减少了内存消耗和事件处理程序数量，特别是在处理大量子元素的情况下非常有用。
事件流模型是描述事件如何在DOM结构中传播的方式，主要有捕获模型和冒泡模型。现代浏览器中，通常同时支持两个模型，开发者可以选择使用其中一个或两者结合来处理事件

## 闭包概念？应用场景？引起问题？
闭包指的是函数和它周围的词法环境的组合，它使函数能够访问在其外部定义的变量，即使在函数本身执行完毕后仍然可以访问这些变量。
用于创建私有变量以防止外部代码访问或修改这些变量。这对于模块化开发非常有用。保持对外部变量的引用，延长变量的生命周期
问题：
  1. 如果不小心使用闭包，它们可能导致内存泄漏。当闭包引用了大量内存或循环引用时，垃圾收集器可能无法回收不再使用的内存
  2. 过度使用闭包可能导致性能问题，因为每个闭包都会创建新的作用域链，这可能会增加执行时间和内存开销。 

## ES6新特性？
块级作用域（let和const）、剪头函数、模板字符串、解构赋值、默认参数值、模块、Promise、Proxy、扩展操作服（...）、新的数据结构（Set，Map）、Symbol

## Generator？
生成器，返回一个遍历器，通过.next()接续下一步

## 防抖与节流的实现？应用场景？区别？
都是为了降低回调执行频率
 - 防抖：一段时间内，多次触发同一事件，但只执行最后一次。防抖通常是搜索输入框、输入框格式校验、还有窗口resize、表单提交按钮
    ```js
    function throttled(fn, delay = 500) {
        let timer = null
        return function (...args) {
            if (!timer) {
                timer = setTimeout(() => {
                    fn.apply(this, args)
                    timer = null
                }, delay);
            }
        }
    }
    ```
 - 节流：多次触发，但在一段时间只执行一次。滚动事件、限制请求事件请求频率、滚动加载（加载更多或滚到底部监听
    ```js
    function debounce(func, wait) {
        let timeout;
        return function () {
            let context = this; // 保存this指向
            let args = arguments; // 拿到event对象
            clearTimeout(timeout)
            timeout = setTimeout(function(){
                func.apply(context, args)
            }, wait);
        }
    }
    ```

## call、apply、bind函数异同？
作用是改变函数执行时的上下文，简而言之就是改变函数运行时的this指向  
三者都可以改变函数的this对象指向  
三者第一个参数都是this要指向的对象，如果如果没有这个参数或参数为undefined或null，则默认指向全局window  
三者都可以传参，但是apply是数组，而call是参数列表，且apply和call是一次性传入参数，而bind可以分为多次传入  
bind是返回绑定this之后的函数，apply、call 则是立即执行  

## 剪头函数和普通函数的区别？
从形式上：一个使用箭头（=>），一个使用function关键字声明
从this：剪头函数指向定义箭头函数的上下文，没有自己的this。普通函数则根据调用方式有所区别，通常指向调用函数的对象或全局对象  
从构造函数：箭头函数不能用作构造函数，也就不能通过new来实例化它们。普通函数则支持new操作  
arguments：箭头函数没有arguments对象，普通函数可通过arguments对象访问传递给函数的参数

## 递归遇到循环引用该怎么办？
- 限制递归深度
- 使用集合来跟踪已访问的对象，使用一个Set或对象来跟踪已经访问过的对象，以便在后续的递归调用中避免重复访问
- 修改数据结构，修改数据结构以避免循环引用
- 优化递归算法

## let和const的区别？以及var？
用var声明的变量既是全局变量，也是顶层变量，顶层变量可通过window对象访问，var存在变量提升，可声明在后  
let用法类似var，但只在声明所在代码块内有效，且访问变量不能在声明之前，也不能重复声明相同变量
const声明一个只读的常量，一旦声明，常量的值就不能改变。引用数据类型除外，因为保存的是指向实际数据的内存地址
let和const存在暂时性死区，只有等到声明变量的那一行代码出现，才可以获取和使用该变量
let和const存在块级作用域

## axios的二次封装？
设置借口请求前缀、超时时间、请求头
在响应拦截器中可以判断与后端规约好的code值，对失败统一作提醒

## 图片懒加载？资源预加载？
优化网页性能的技术，它延迟加载页面上的图片，直到用户滚动到它们附近的位置。这可以减少初始页面加载时间，减轻服务器和带宽负担
用于提高网页性能的技术，通过在页面加载过程中提前加载将来可能需要的资源，以减少延迟和提高用户体验。资源预加载通常用于加载页面所需的资源，如图像、CSS、JavaScript文件等。使用link、script标签配合preload属性开启预加载，也可通过Image对象

## 数组去重有哪些办法？
使用Set数据结构、循环判断（循环的方法很多filter、map、for...of、reduce、indexOf等等）、利用对象键名不可重复

## 0.1+0.2 != 0.3 ？
浮点数在计算机中以二进制表示，而很多小数值（如0.1和0.2）的二进制表示是无限循环的，无法精确表示
Math.js、BigDecimal.js
扩大原来数据到一定倍数（10的倍数），保证所需要保留的小数位数以整数参与计算，最后再除上扩大的倍数
toFixed（）保留小数

