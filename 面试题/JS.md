## BOM对象有哪些？
浏览器对象模型，提供了独立于内容与浏览器窗口进行交互的对象  
其作用就是跟浏览器做一些交互效果,比如如何进行页面的后退，前进，刷新，浏览器的窗口发生变化，滚动条的滚动，以及获取客户的一些信息如：浏览器品牌版本，屏幕分辨率  
Bom的核心对象是window，它表示浏览器的一个实例，在浏览器中，window对象有双重角色，即是浏览器窗口的一个接口，又是全局对象  
location、navigator（浏览器信息）、screen（显示器信息）、history

## 刷新页面的方式
 - location.reload(true?) 参数为true强制浏览器绕过缓存并重新加载页面
 - location.href window.location.href = window.location.href 对location.href赋值
 - location.replace() 用于在不添加历史记录的情况下刷新页面，将当前页面替换为新页面，从而实现刷新效果

## iframe的顶层对象
 - window.top 指向顶层窗口的全局JavaScript对象。通过window.top，您可以在iframe中执行顶层窗口中的JavaScript代码，或者与顶层窗口进行通信。
 - window.parent 是一个指向包含iframe的父窗口的全局JavaScript对象，访问父窗口的DOM、执行父窗口中的JavaScript代码，或者与父窗口进行通信

## base64算法原理？会什么会使数据量变大？变大了多少？
二进制到文本编码方案  
包括大写字母（A-Z）、小写字母（a-z）、数字（0-9）以及两个额外的字符（通常是"+"和"/"），共64字符  
  - 数据分组（3个字节/组【24位】，不足3字节则额外添加零字节）
  - 数据转化：原3个字节数据的二进制按位排列为一个长的二进制数字（24位整数）
  - 整数分割：将24位二进制整数按6位一组分割，2^6=64
  - 字符映射：每个6位的二进制数字转换为对应的Base64字符
  - 如果原始数据的长度不是3的倍数，将在末尾添加一些额外字符，通常是等号("=")，以确保输出是4的倍数
3个字节转换为4个base64字符，一个字符又对应了单个或多个字节，数据发生了膨胀，至少变大33%，以及位数不足时，“=”符号的补位

## 重排重绘？哪些api会引起？怎么优化？（重绘&回流）
  - 重排（回流）：布局引擎会根据各种样式计算每个盒子在页面上的大小与位置，当页面布局和几何信息发生变化的时候，例如添加删除元素、改变元素位置和大小，获取元素宽高位置信息也会触发（offsetTop、offsetLeft、 offsetWidth、offsetHeight、scrollTop、scrollLeft等，getComputedStyle方法也会触发）
  - 重绘：在回流之后，浏览器根据每个盒子特性进行绘制，触发回流一定会触发重绘，例如改变字体或背景颜色、文字排列对齐方式、阴影修改
  优化：1. 用修改元素的类名而不是直接修改样式属性  2.避免在 JavaScript 中查询元素的尺寸和位置信息，因为这可能会强制浏览器进行同步布局，导致重排。如果需要获取这些信息，可以使用 getBoundingClientRect() 等方法  3. CSS 动画和过渡通常比使用 JavaScript 进行动画更高效  4. 使用节流和防抖来限制事件处理的频率，以减少不必要的重排和重绘  5. 批量DOM操作，批量添加

## promise是什么？为什么产生回调地狱？
异步编程的一种解决方案，传统回掉会有多层嵌套，代码可读性差，promise链式操作减低了编码难度，代码可读性明显增强  
promise有三种状态：pending（进行中）、fulfilled（已成功）、rejected（已失败）
异步操作的嵌套，可读性差，错误处理困难，结构混乱

## 不用promise，怎么实现promise.all（实现第一个，第二个任务后，才执行第三个任务？用发布订阅实现，前两任务会同时派发吗，为什么？）
采用回调，对完成任务计数

## 怎么实现promise.race？


## 发布订阅模式和观察者模式的区别
观察者模式，观察者明确知道被观察对像，并订阅被观察者，当被观察者发生变化，会通知观察者，相互之间直接联系。通常一个被观察者对应多个观察者，每个观察者订阅同一被观察者事件    
发布-订阅模式，需要通过一个中间者，联系发布者和订阅者，它们之间互不感知，可以有多个发布者，订阅者只需要订阅感兴趣的内容

## 怎么处理长任务？
 1. 分割任务
 2. 使用异步编程
 3. 标识执行进度
 4. 优化算法，提高效率
 5. 定时器（确保任务不会无限期执行，及时通知用户）

## 如何按顺序发送多个请求（请求可能会失败）
 1. 回调
 2. promise异步编程
 3. async/await 异步编程

## 如何实现一个防止重复请求的方法？
记录请求地址，在拦截器中判断是否重复
取消请求 axios中的cancelToken或者使用promise当取消请求时直接reject返回

## 事件循环机制？宏任务？微任务？（js和node）js单线程，为什么会有异步任务
JavaScript是一门单线程的语言，意味着同一时间内只能做一件事，但是这并不意味着单线程就是阻塞，而实现单线程非阻塞的方法就是事件循环   
任务：
  - 同步任务：立即执行的任务，同步任务一般会直接进入到主线程中执行
  - 异步任务：异步执行的任务，比如ajax网络请求，setTimeout定时函数等
事件循环：同步任务进入主线程，即主执行栈，异步任务进入任务队列，主线程内的任务执行完毕为空，会去任务队列读取对应的任务，推入主线程执行。上述过程的不断重复就事件循环  
异步任务还可以细分为微任务与宏任务  
  - 微任务：一个需要异步执行的函数，执行时机是在主函数执行结束之后、当前宏任务结束之前。常见的微任务有：Promise.then、MutaionObserver（监视DOM变化）、Object.observe（已废弃；Proxy 对象替代）、process.nextTick（Node.js）
  - 宏任务：宏任务的时间粒度比较大，执行的时间间隔是不能精确控制的，对一些高实时性的需求就不太符合，script (可以理解为外层同步代码)、setTimeout/setInterval、UI rendering/UI事件、postMessage、MessageChannel、setImmediate、I/O（Node.js）
当前正执行一个宏任务，如果遇到微任务就将它放到微任务的事件队列中，当前宏任务执行完成后，会查看微任务的事件队列，然后将里面的所有微任务依次执行完

## js原型，原型链？
JS在创建对象的时候会关联另外一个对象，该对象即是当前所创建对象的原型，每个新创建的对象会从原型继承属性  
原型又会有自己关联的原型，一直关联至Object，这就形成了原型链

## 浅拷贝？深拷贝？
浅拷贝：如果属性是基本类型，拷贝的就是基本类型的值。如果属性是引用类型，拷贝的就是内存地址。Object.assign、slice、concat、拓展运算符实现的复制
深拷贝：复制后引用数据类型改动后互不影响。JSON.stringify()、手写递归复制

## JSON.stringfy方法有什么缺点？
对undefined、symbol、function会被忽略
不支持循环引用
不支持日期对象

## 作用域是什么？
作用域是变量和函数生效的区域合集，作用域决定了代码区块中变量和其他资源的可见性  
作用域包括全局作用域、函数作用域、块级作用域  
作用域链：代码执行时，变量首先会在当前作用域中寻找，没有找到就到上一层作用域查找，最后在全局作用域中寻找

## async/await和promise的区别？实现原理？


## 介绍一些new的过程中，有哪些步骤？

## 如何实现打印功能？

## js基本数据类型和引用数据类型，如何判断类型？

## this指向问题？

## 事件捕捉？事件冒泡？事件代理？事件流模型？

## 闭包概念？应用场景？引起问题？

## ES6新特性？

## Generator？

## 防抖与节流的实现？应用场景？区别？

## call、apply、bind函数异同？

## 剪头函数和普通函数的区别？

## 递归遇到循环引用该怎么办？

## let和const的区别？以及var？

## axios的二次封装？

## 图片懒加载？资源预加载？

## 数组去重有哪些办法？

## 0.1+0.2 != 0.3 ？

